#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@author: Safinez Boumaiza
Purpose : PCA
"""

######################### PCA ############################
# We have a data with more than 2/3 dimension ==>
# PCA is the solution to reduce your data to 2/3 dimensions
# Makes the data visualisation easier
# For that we need to proceed with a normalization
# Normalisation : to the comparaison possible for variables with different unities and scales


# Import packages
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn import preprocessing
from sklearn import decomposition
from sklearn.decomposition import PCA

def data_management(input_file1,input_file2 ):
    '''
    This function aims to gather two dataframes into one based on the datetime column, calculate tmrt-Ta
    :param input_file: name of the data file to import
    :return: One input file (dataframe)
    '''
    # Import Data
    final_data = pd.read_excel(input_file1, indexcol=0, nrows= 2880)
    utci_tmrt = pd.read_excel(input_file2, indexcol=0, nrows= 2880)
    utci_tmrt.rename(columns={utci_tmrt.columns[0]: "datetime"}, inplace=True)

    # Jointure
    df_joined_inputs = pd.merge(left=final_data, right=utci_tmrt, left_on='datetime', right_on='datetime')

    # TMRT-Ta calculation
    df_joined_inputs['tmrt-ta'] = df_joined_inputs['T_mrt'] - df_joined_inputs['Temp_air_2m']

    # Creation of the table_offset
    df_interest_inputs = df_joined_inputs[
        ['datetime', 'Temp_air_2m', 'tmrt-ta', 'WindSpeed', 'RelativeHumidity', 'UTCI']]

    ## Arrondir
    df_final_input = df_interest_inputs.round({"Temp_air_2m": 0, "tmrt-ta": 0, "WindSpeed": 1, 'RelativeHumidity': 0})

    ## Trier
    return df_final_input


def display_scree_plot(pca):
    """
    This function aims to determin the number of principal axis we need to project our data
    The choice is based on the inertia of the nuage projected on each axis
    :param pca: Data
    :return: A scree plot
    """
    # explained_variance_ratio_ : Percentage of variance explained by each of the selected components
    scree = pca.explained_variance_ratio_*100
    plt.bar(np.arange(len(scree))+1, scree)
    plt.plot(np.arange(len(scree))+1, scree.cumsum(),c="red",marker='o')
    plt.xlabel("rank of the axis")
    plt.ylabel("% of inertia")
    plt.title("Sree plot")
    plt.show(block=False)


def display_circles(pcs, n_comp, pca, axis_ranks, labels=None, label_rotation=0, lims=None):
    for d1, d2 in axis_ranks:
        # Plot the 2 factorial plans/ 4 compnents
        if d2 < n_comp:

            # Initialisation of the plot
            fig, ax = plt.subplots(figsize=(7, 6))

            # Determination of the limits of the graphic
            if lims is not None:
                xmin, xmax, ymin, ymax = lims
            elif pcs.shape[1] < 30:
                xmin, xmax, ymin, ymax = -1, 1, -1, 1
            else:
                xmin, xmax, ymin, ymax = min(pcs[d1, :]), max(pcs[d1, :]), min(pcs[d2, :]), max(pcs[d2, :])

            # Displaying the arrows
            if pcs.shape[1] < 30:
                plt.quiver(np.zeros(pcs.shape[1]), np.zeros(pcs.shape[1]),
                           pcs[d1, :], pcs[d2, :],
                           angles='xy', scale_units='xy', scale=1, color="black")
            else:
                lines = [[[0, 0], [x, y]] for x, y in pcs[[d1, d2]].T]
                ax.add_collection(LineCollection(lines, axes=ax, alpha=.1, color='grey'))

            # Adding the name of each variable on the circle
            if labels is not None:
                for i, (x, y) in enumerate(pcs[[d1, d2]].T):
                    if x >= xmin and x <= xmax and y >= ymin and y <= ymax:
                        plt.text(x, y, labels[i], fontsize='14', ha='center', va='center', rotation=label_rotation,
                                 color="red")

            # Display the circle
            circle = plt.Circle((0, 0), 1, facecolor='none', edgecolor='b')
            plt.gca().add_artist(circle)

            # Display of the vertical and horizontal axis
            plt.plot([-1, 1], [0, 0], color='blue', ls='--')
            plt.plot([0, 0], [-1, 1], color='blue', ls='--')

            # Names of the different axis and % of inertia
            plt.xlabel('F{} ({}%)'.format(d1 + 1, round(100 * pca.explained_variance_ratio_[d1], 1)))
            plt.ylabel('F{} ({}%)'.format(d2 + 1, round(100 * pca.explained_variance_ratio_[d2], 1)))

            plt.title("Correlation circle (F{} et F{})".format(d1 + 1, d2 + 1))
            plt.show(block=False)


def display_factorial_planes(X_projected, n_comp, pca, axis_ranks, labels=None, alpha=1, illustrative_var=None):
    for d1, d2 in axis_ranks:
        if d2 < n_comp:

            # Initialisation of the plot
            fig = plt.figure(figsize=(7, 6))

            # Displaying the points
            if illustrative_var is None:
                plt.scatter(X_projected[:, d1], X_projected[:, d2], alpha=alpha)
            else:
                illustrative_var = np.array(illustrative_var)
                for value in np.unique(illustrative_var):
                    selected = np.where(illustrative_var == value)
                    plt.scatter(X_projected[selected, d1], X_projected[selected, d2], alpha=alpha, label=value)
                plt.legend()

            # Displaying the label for each point
            if labels is not None:
                for i, (x, y) in enumerate(X_projected[:, [d1, d2]]):
                    plt.text(x, y, labels[i],
                             fontsize='14', ha='center', va='center')

            # Limits of our graphic
            boundary = np.max(np.abs(X_projected[:, [d1, d2]])) * 1.1
            plt.xlim([-boundary, boundary])
            plt.ylim([-boundary, boundary])

            # Display of the horizontal and vertical axis
            plt.plot([-100, 100], [0, 0], color='grey', ls='--')
            plt.plot([0, 0], [-100, 100], color='grey', ls='--')

            # Names of the different axis and % of inertia
            plt.xlabel('F{} ({}%)'.format(d1 + 1, round(100 * pca.explained_variance_ratio_[d1], 1)))
            plt.ylabel('F{} ({}%)'.format(d2 + 1, round(100 * pca.explained_variance_ratio_[d2], 1)))

            plt.title("Projection of each value per minute ( F{} and F{})".format(d1 + 1, d2 + 1))
            plt.show(block=False)

##################################################################################################
if __name__ == "__main__":
    pd.set_option('display.max_columns', None)

    # Import data
    df_input = data_management('final_data.xlsx', 'UTCI_TMRT.xlsx')
    # print(df_input.describe())
    print(df_input.head(5))

    # Number of components to consider : min(p, n-1) (p : var , n: indiv)
    n_comp = 5

    # Select data for PCA analysis
    data_pca = df_input[["Temp_air_2m","tmrt-ta","WindSpeed","RelativeHumidity","UTCI"]]
    # Transform to array numpy
    X = data_pca.values
    names = data_pca.index
    features = data_pca.columns

    # Standardization : mean removal and variance scaling
    # (removing the mean value of each feature then scaling it \
    # by dividing non-constant features by their standard deviation)
    std_scale = preprocessing.StandardScaler().fit(X)
    X_scaled = std_scale.transform(X)

    # Calculation of principal components
    # Linear dimensionality reduction using Singular Value \
    # Decomposition of the data to project it to a lower dimensional space
    pca = decomposition.PCA(n_components=n_comp)
    pca.fit(X_scaled)

    # Diagramme des valeurs propres / Scree diagram
    # Helps to determin the number of factorial plans/ main components
    display_scree_plot(pca)
    # ==> In our case it's 2 plans / 4 components

    # Correlation circle : projection of variables ==> to study the link between them (correlation)
    pcs = pca.components_
    display_circles(pcs, n_comp, pca, [(0, 1), (2, 3)], labels=np.array(features))

    # Projection of individuals/
    X_projected = pca.transform(X_scaled)
    display_factorial_planes(X_projected, n_comp, pca, [(0, 1), (2, 3)], labels=np.array(names))

    plt.show()